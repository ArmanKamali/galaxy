{"version":3,"sources":["viz/trackster/painters.js"],"names":["compute_overlap","first_region","second_region","first_start","first_end","second_start","second_end","BEFORE","OVERLAP_START","CONTAINS","AFTER","CONTAINED_BY","OVERLAP_END","is_overlap","overlap","dashedLine","ctx","x1","y1","x2","y2","dashLen","undefined","dX","dY","dashes","Math","floor","sqrt","q","dashX","dashY","NO_DETAIL_TRACK_HEIGHT","LABEL_SPACING","down_vertex_x","down_vertex_y","side_len","y","beginPath","moveTo","lineTo","strokeStyle","this","fillStyle","fill","stroke","_","Scaler","default_val","_classCallCheck","DrawResults","feature_mapper","Painter","view_end","prefs","mode","data","extend","default_prefs","width","height","w_scale","chrom_pos","closePath","_chrom_pos_to_draw_pos","offset","max","view_start","LinePainter","_possibleConstructorReturn","__proto__","Object","getPrototypeOf","call","in_path","min_value","max_value","vertical_range","height_px","incomplete_features","options","save","y_zero","round","fillRect","x_scaled","delta_x_pxs","length","map","slice","d","ceil","i","delta_x_px","painter_color","block_color","color","pref_color","parseInt","pref_r","pref_g","pref_b","top_overflow","bot_overflow","len","saturation","new_r","new_g","new_b","overflow_color","overflow_x","FeaturePositionMapper","slot_height","feature_positions","translation","feature_data","slot","x_start","x_end","x","feature_dict","y_translation","FeaturePainter","alpha_scaler","height_scaler","_this2","max_label_length","rows_required","required_height","get_row_height","y_scale","get_top_padding","slots","textAlign","x_draw_coords","feature","feature_uid","feature_start","feature_end","draw_element","push","restore","tile_low","tile_high","LinkedFeaturePainter","_this3","draw_background_connector","draw_individual_connectors","feature_name","feature_strand","f_start","f_end","min","draw_start","draw_end","thick_end","reverse_strand_color","label_color","globalAlpha","gen_val","y_start","feature_te","feature_blocks","full_height","feature_ts","thin_height","thick_height","cur_y_start","SQUISH_FEATURE_HEIGHT","cur_height","canvas","NO_DETAIL_FEATURE_HEIGHT","manager","get_pattern","k","k_len","thick_start","block_start","block","block_end","block_thick_start","block_thick_end","last_block_start","last_block_end","hscale_factor","new_height","ws_height","SQUISH_TRACK_HEIGHT","PACK_TRACK_HEIGHT","measureText","fillText","ReadPainter","ref_seq","base_color_fn","_this4","cigar_str","blocks","base_pos","parsed_cigar","match","op","op_char","op_len","indexOf","cigar","strand","read_seq","get_draw_coord","sequence_coord","s_start","s_end","DENSE_TRACK_HEIGHT","base_offset","gap","char_width_px","show_insertions","detail_block_color","pack_mode","draw_height","rect_y","paint_utils","ReadPainterUtils","drawing_blocks","draw_last","t","_parse_cigar","tile_region","cur_block","cigar_ops","cig","cig_id","cig_op","cig_len","seq_start","update_base_offset","cur_seq","seq_offset","show_differences","c_start","start_pos","c","insert_x_coord","x_center","type","seq","str_len","update_seq_offset","item","font","drawDownwardEquilateralTriangle","Array","connector","draw_read","b1_end","b2_start","line_height","ArcLinkedFeaturePainter","_this5","longest_feature_length","block1_start","block1_end","block2_start","block2_end","arc","PI","Color","rgb","a","isArray","substring","alpha","radius","toString","join","h","s","r","g","b","l","concat","color2","weight","color1","p","w","toHSL","w1","w2","LinearRamp","start_color","end_color","start_value","end_value","value_range","value","argb","mix","toCSS","SplitRamp","middle_color","positive_ramp","negative_ramp","map_value","DiagonalHeatmapPainter","_this6","Infinity","s1","e1","s2","invsqrt2","ramp","neg_color","pos_color","scale","rotate","e2","row_height","px_per_base","draw_details","delete_details_thickness","thickness","VariantPainter","_this7","divider_height","num_samples","summary_height","show_sample_data","locus_data","pos","ref","alt","sample_gts","allele_counts","variant","draw_x_start","draw_y_start","genotype","j","get_indel_info","ref_len","alt_len","start","base_px","split","draw_summary","feature_height","alt_info","indel_info","get_start_draw_pos","allele_frac","snp","get_draw_pos","draw_deletion"],"mappings":"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","file":"../../../scripts/viz/trackster/painters.js","sourcesContent":["import * as _ from \"libs/underscore\";\n// Constants specific to feature tracks moved here (HACKING, these should\n// basically all be configuration options)\nconst BEFORE = 1001;\nconst CONTAINS = 1002;\nconst OVERLAP_START = 1003;\nconst OVERLAP_END = 1004;\nconst CONTAINED_BY = 1005;\nconst AFTER = 1006;\n\nconst DENSE_TRACK_HEIGHT = 10;\nconst NO_DETAIL_TRACK_HEIGHT = 3;\nconst SQUISH_TRACK_HEIGHT = 5;\nconst PACK_TRACK_HEIGHT = 10;\nconst NO_DETAIL_FEATURE_HEIGHT = 1;\nconst DENSE_FEATURE_HEIGHT = 9;\nconst SQUISH_FEATURE_HEIGHT = 3;\nconst PACK_FEATURE_HEIGHT = 9;\nconst LABEL_SPACING = 2;\nconst CONNECTOR_COLOR = \"#ccc\";\n\n/**\n * Compute the type of overlap between two regions. They are assumed to be on the same chrom/contig.\n * The overlap is computed relative to the second region; hence, OVERLAP_START indicates that the first\n * region overlaps the start (but not the end) of the second region.\n * NOTE: Coordinates are assumed to be in BED format: half open (start is closed, end is open).\n */\nfunction compute_overlap(first_region, second_region) {\n    var first_start = first_region[0];\n    var first_end = first_region[1];\n    var second_start = second_region[0];\n    var second_end = second_region[1];\n    var overlap;\n    if (first_start < second_start) {\n        if (first_end <= second_start) {\n            overlap = BEFORE;\n        } else if (first_end <= second_end) {\n            overlap = OVERLAP_START;\n        } else {\n            // first_end > second_end\n            overlap = CONTAINS;\n        }\n    } else {\n        // first_start >= second_start\n        if (first_start > second_end) {\n            overlap = AFTER;\n        } else if (first_end <= second_end) {\n            overlap = CONTAINED_BY;\n        } else {\n            overlap = OVERLAP_END;\n        }\n    }\n    return overlap;\n}\n\n/**\n * Returns true if regions overlap.\n */\nfunction is_overlap(first_region, second_region) {\n    var overlap = compute_overlap(first_region, second_region);\n    return overlap !== BEFORE && overlap !== AFTER;\n}\n\n/**\n * Draw a dashed line on a canvas using filled rectangles. This function is based on:\n * http://vetruvet.blogspot.com/2010/10/drawing-dashed-lines-on-html5-canvas.html\n * However, that approach uses lines, which don't seem to render as well, so use\n * rectangles instead.\n */\nfunction dashedLine(ctx, x1, y1, x2, y2, dashLen) {\n    if (dashLen === undefined) {\n        dashLen = 4;\n    }\n    var dX = x2 - x1;\n    var dY = y2 - y1;\n    var dashes = Math.floor(Math.sqrt(dX * dX + dY * dY) / dashLen);\n    var dashX = dX / dashes;\n    var dashY = dY / dashes;\n    var q;\n\n    for (q = 0; q < dashes; q++, x1 += dashX, y1 += dashY) {\n        if (q % 2 !== 0) {\n            continue;\n        }\n        ctx.fillRect(x1, y1, dashLen, 1);\n    }\n}\n\n/**\n * Draw an isosceles triangle that points down.\n */\nfunction drawDownwardEquilateralTriangle(ctx, down_vertex_x, down_vertex_y, side_len) {\n    // Compute other two points of triangle.\n    var x1 = down_vertex_x - side_len / 2;\n\n    var x2 = down_vertex_x + side_len / 2;\n    var y = down_vertex_y - Math.sqrt(side_len * 3 / 2);\n\n    // Draw and fill.\n    ctx.beginPath();\n    ctx.moveTo(x1, y);\n    ctx.lineTo(x2, y);\n    ctx.lineTo(down_vertex_x, down_vertex_y);\n    ctx.lineTo(x1, y);\n\n    ctx.strokeStyle = this.fillStyle;\n    ctx.fill();\n    ctx.stroke();\n    ctx.closePath();\n}\n\n/**\n * Base class for all scalers. Scalers produce values that are used to change (scale) drawing attributes.\n */\nclass Scaler {\n    constructor(default_val) {\n        this.default_val = default_val ? default_val : 1;\n    }\n\n    /**\n     * Produce a scaling value.\n     */\n    gen_val(input) {\n        return this.default_val;\n    }\n}\n\n/**\n * Results from painter.draw()\n */\nclass DrawResults {\n    constructor(options) {\n        this.incomplete_features = options.incomplete_features;\n        this.feature_mapper = options.feature_mapper;\n    }\n}\n\n/**\n * Base class for painters\n *\n * -- Mode and prefs are both optional\n */\nclass Painter {\n    constructor(data, view_start, view_end, prefs, mode) {\n        // Data and data properties\n        this.data = data;\n        this.default_prefs = {};\n        // View\n        this.view_start = view_start;\n        this.view_end = view_end;\n        // Drawing prefs\n        this.prefs = _.extend({}, this.default_prefs, prefs);\n        this.mode = mode;\n    }\n\n    static get default_prefs() {\n        return {};\n    }\n\n    /**\n     * Draw on the context using a rectangle of width x height using scale w_scale.\n     */\n    draw(ctx, width, height, w_scale) {}\n\n    /**\n     * Get starting drawing position, which is offset a half-base left of coordinate.\n     */\n    get_start_draw_pos(chrom_pos, w_scale) {\n        return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, -0.5);\n    }\n\n    /**\n     * Get end drawing position, which is offset a half-base right of coordinate.\n     */\n    get_end_draw_pos(chrom_pos, w_scale) {\n        return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, 0.5);\n    }\n\n    /**\n     * Get drawing position.\n     */\n    get_draw_pos(chrom_pos, w_scale) {\n        return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, 0);\n    }\n\n    /**\n     * Convert chromosome position to drawing position.\n     */\n    _chrom_pos_to_draw_pos(chrom_pos, w_scale, offset) {\n        return Math.floor(w_scale * (Math.max(0, chrom_pos - this.view_start) + offset));\n    }\n}\n\nclass LinePainter extends Painter {\n    constructor(data, view_start, view_end, prefs, mode) {\n        super(data, view_start, view_end, prefs, mode);\n    }\n\n    static get default_prefs() {\n        return {\n            min_value: undefined,\n            max_value: undefined,\n            mode: \"Histogram\",\n            color: \"#000\",\n            overflow_color: \"#F66\"\n        };\n    }\n\n    draw(ctx, width, height, w_scale) {\n        var in_path = false;\n        var min_value = this.prefs.min_value;\n        var max_value = this.prefs.max_value;\n        var vertical_range = max_value - min_value;\n        var height_px = height;\n        var view_start = this.view_start;\n        var mode = this.mode;\n        var data = this.data;\n\n        ctx.save();\n\n        // Pixel position of 0 on the y axis\n        var y_zero = Math.round(height + min_value / vertical_range * height);\n\n        // Horizontal line to denote x-axis\n        if (mode !== \"Intensity\") {\n            ctx.fillStyle = \"#aaa\";\n            ctx.fillRect(0, y_zero, width, 1);\n        }\n\n        ctx.beginPath();\n        var x_scaled;\n        var y;\n        var delta_x_pxs;\n        if (data.length > 1) {\n            delta_x_pxs = _.map(data.slice(0, -1), (d, i) => Math.ceil((data[i + 1][0] - data[i][0]) * w_scale));\n        } else {\n            delta_x_pxs = [10];\n        }\n\n        // Painter color can be in either block_color (FeatureTrack) or color pref (LineTrack).\n        var painter_color = this.prefs.block_color || this.prefs.color;\n\n        var // Extract RGB from preference color.\n        pref_color = parseInt(painter_color.slice(1), 16);\n        var pref_r = (pref_color & 0xff0000) >> 16;\n        var pref_g = (pref_color & 0x00ff00) >> 8;\n        var pref_b = pref_color & 0x0000ff;\n        var top_overflow = false;\n        var bot_overflow = false;\n\n        // Paint track.\n        var delta_x_px;\n        for (var i = 0, len = data.length; i < len; i++) {\n            // Reset attributes for next point.\n            ctx.fillStyle = ctx.strokeStyle = painter_color;\n            top_overflow = bot_overflow = false;\n            delta_x_px = delta_x_pxs[i];\n\n            x_scaled = Math.floor((data[i][0] - view_start - 0.5) * w_scale);\n            y = data[i][1];\n\n            // Process Y (scaler) value.\n            if (y === null) {\n                if (in_path && mode === \"Filled\") {\n                    ctx.lineTo(x_scaled, height_px);\n                }\n                in_path = false;\n                continue;\n            }\n\n            // Bound Y value by min, max.\n            if (y < min_value) {\n                bot_overflow = true;\n                y = min_value;\n            } else if (y > max_value) {\n                top_overflow = true;\n                y = max_value;\n            }\n\n            // Draw point.\n            if (mode === \"Histogram\") {\n                // y becomes the bar height in pixels, which is the negated for canvas coords\n                y = Math.round(y / vertical_range * height_px);\n                ctx.fillRect(x_scaled, y_zero, delta_x_px, -y);\n            } else if (mode === \"Intensity\") {\n                var saturation = (y - min_value) / vertical_range;\n\n                var // Range is [pref_color, 255] where saturation = 0 --> 255 and saturation = 1 --> pref color\n                new_r = Math.round(pref_r + (255 - pref_r) * (1 - saturation));\n\n                var new_g = Math.round(pref_g + (255 - pref_g) * (1 - saturation));\n                var new_b = Math.round(pref_b + (255 - pref_b) * (1 - saturation));\n                ctx.fillStyle = `rgb(${new_r},${new_g},${new_b})`;\n                ctx.fillRect(x_scaled, 0, delta_x_px, height_px);\n            } else {\n                // mode is Coverage/Line or Filled.\n\n                // Scale Y value.\n                y = Math.round(height_px - (y - min_value) / vertical_range * height_px);\n                if (in_path) {\n                    ctx.lineTo(x_scaled, y);\n                } else {\n                    in_path = true;\n                    if (mode === \"Filled\") {\n                        ctx.moveTo(x_scaled, height_px);\n                        ctx.lineTo(x_scaled, y);\n                    } else {\n                        ctx.moveTo(x_scaled, y);\n                        // Use this approach (note: same as for filled) to draw line from 0 to\n                        // first data point.\n                        //ctx.moveTo(x_scaled, height_px);\n                        //ctx.lineTo(x_scaled, y);\n                    }\n                }\n            }\n\n            // Draw lines at boundaries if overflowing min or max\n            ctx.fillStyle = this.prefs.overflow_color;\n            if (top_overflow || bot_overflow) {\n                var overflow_x;\n                if (mode === \"Histogram\" || mode === \"Intensity\") {\n                    overflow_x = delta_x_px;\n                } else {\n                    // Line and Filled, which are points\n                    x_scaled -= 2; // Move it over to the left so it's centered on the point\n                    overflow_x = 4;\n                }\n                if (top_overflow) {\n                    ctx.fillRect(x_scaled, 0, overflow_x, 3);\n                }\n                if (bot_overflow) {\n                    ctx.fillRect(x_scaled, height_px - 3, overflow_x, 3);\n                }\n            }\n            ctx.fillStyle = painter_color;\n        }\n        if (mode === \"Filled\") {\n            if (in_path) {\n                ctx.lineTo(x_scaled, y_zero);\n                ctx.lineTo(0, y_zero);\n            }\n            ctx.fill();\n        } else {\n            ctx.stroke();\n        }\n\n        ctx.restore();\n    }\n}\n\n/**\n * Mapper that contains information about feature locations and data.\n */\nclass FeaturePositionMapper {\n    constructor(slot_height) {\n        this.feature_positions = {};\n        this.slot_height = slot_height;\n        this.translation = 0;\n        this.y_translation = 0;\n    }\n\n    /**\n     * Map feature data to a position defined by <slot, x_start, x_end>.\n     */\n    map_feature_data(feature_data, slot, x_start, x_end) {\n        if (!this.feature_positions[slot]) {\n            this.feature_positions[slot] = [];\n        }\n        this.feature_positions[slot].push({\n            data: feature_data,\n            x_start: x_start,\n            x_end: x_end\n        });\n    }\n\n    /**\n     * Get feature data for position <x, y>\n     */\n    get_feature_data(x, y) {\n        // Find slot using Y.\n        var slot = Math.floor((y - this.y_translation) / this.slot_height);\n\n        var feature_dict;\n\n        // May not be over a slot due to padding, margin, etc.\n        if (!this.feature_positions[slot]) {\n            return null;\n        }\n\n        // Find feature using X.\n        x += this.translation;\n        for (var i = 0; i < this.feature_positions[slot].length; i++) {\n            feature_dict = this.feature_positions[slot][i];\n            if (x >= feature_dict.x_start && x <= feature_dict.x_end) {\n                return feature_dict.data;\n            }\n        }\n    }\n}\n\n/**\n * Abstract object for painting feature tracks. Subclasses must implement draw_element() for painting to work.\n * Painter uses a 0-based, half-open coordinate system; start coordinate is closed--included--and the end is open.\n * This coordinate system matches the BED format.\n */\nclass FeaturePainter extends Painter {\n    constructor(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler) {\n        super(data, view_start, view_end, prefs, mode);\n        this.alpha_scaler = alpha_scaler ? alpha_scaler : new Scaler();\n        this.height_scaler = height_scaler ? height_scaler : new Scaler();\n        this.max_label_length = 200;\n    }\n\n    static get default_prefs() {\n        return {\n            block_color: \"#FFF\",\n            connector_color: \"#FFF\"\n        };\n    }\n    get_required_height(rows_required, width) {\n        // y_scale is the height per row\n        var required_height = this.get_row_height();\n\n        var y_scale = required_height;\n        var mode = this.mode;\n        // If using a packing mode, need to multiply by the number of slots used\n        if (mode === \"no_detail\" || mode === \"Squish\" || mode === \"Pack\") {\n            required_height = rows_required * y_scale;\n        }\n        return required_height + this.get_top_padding(width);\n    }\n\n    /** Extra padding before first row of features */\n    get_top_padding(width) {\n        return 0;\n    }\n\n    /**\n     * Draw data on ctx using slots and within the rectangle defined by width and height. Returns\n     * a FeaturePositionMapper object with information about where features were drawn.\n     */\n    draw(ctx, width, height, w_scale, slots) {\n        ctx.save();\n        ctx.fillStyle = this.prefs.block_color;\n        ctx.textAlign = \"right\";\n\n        var y_scale = this.get_row_height();\n        var feature_mapper = new FeaturePositionMapper(y_scale);\n        var x_draw_coords;\n        var incomplete_features = [];\n\n        for (var i = 0, len = this.data.length; i < len; i++) {\n            var feature = this.data[i];\n            var feature_uid = feature[0];\n            var feature_start = feature[1];\n            var feature_end = feature[2];\n\n            // Slot valid only if features are slotted and this feature is slotted;\n            // feature may not be due to lack of space.\n            var slot = slots && slots[feature_uid] !== undefined ? slots[feature_uid].slot : null;\n\n            // Draw feature if (a) mode is dense or feature is slotted (as it must be for all non-dense modes) and\n            // (b) there's overlap between the feature and drawing region.\n            if (\n                (this.mode === \"Dense\" || slot !== null) &&\n                (feature_start < this.view_end && feature_end > this.view_start)\n            ) {\n                x_draw_coords = this.draw_element(\n                    ctx,\n                    this.mode,\n                    feature,\n                    slot,\n                    this.view_start,\n                    this.view_end,\n                    w_scale,\n                    y_scale,\n                    width\n                );\n                feature_mapper.map_feature_data(feature, slot, x_draw_coords[0], x_draw_coords[1]);\n\n                // Add to incomplete features if it's not drawn completely in region.\n                if (feature_start < this.view_start || feature_end > this.view_end) {\n                    incomplete_features.push(feature);\n                }\n            }\n        }\n\n        ctx.restore();\n\n        feature_mapper.y_translation = this.get_top_padding(width);\n        return new DrawResults({\n            incomplete_features: incomplete_features,\n            feature_mapper: feature_mapper\n        });\n    }\n\n    /**\n     * Abstract function for drawing an individual feature.\n     */\n    draw_element(ctx, mode, feature, slot, tile_low, tile_high, w_scale, y_scale, width) {\n        return [0, 0];\n    }\n}\n\nclass LinkedFeaturePainter extends FeaturePainter {\n    constructor(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler) {\n        super(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler);\n        // Whether to draw a single connector in the background that spans the entire feature (the intron fishbone)\n        this.draw_background_connector = true;\n        // Whether to call draw_connector for every pair of blocks\n        this.draw_individual_connectors = false;\n    }\n\n    /**\n     * Height of a single row, depends on mode\n     */\n    get_row_height() {\n        var mode = this.mode;\n        var height;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        } else if (mode === \"no_detail\") {\n            height = NO_DETAIL_TRACK_HEIGHT;\n        } else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        } else {\n            // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n        }\n        return height;\n    }\n\n    /**\n     * Draw a feature. Returns an array with feature's start and end X coordinates.\n     */\n    draw_element(ctx, mode, feature, slot, tile_low, tile_high, w_scale, y_scale, width) {\n        // var feature_uid = feature[0];\n        var feature_start = feature[1];\n        var feature_end = feature[2];\n        var feature_name = feature[3];\n        var feature_strand = feature[4];\n        // -0.5 to offset region between bases.\n        var f_start = Math.floor(Math.max(0, (feature_start - tile_low - 0.5) * w_scale));\n        var f_end = Math.ceil(Math.min(width, Math.max(0, (feature_end - tile_low - 0.5) * w_scale)));\n        var draw_start = f_start;\n        var draw_end = f_end;\n        var y_start = (mode === \"Dense\" ? 0 : 0 + slot) * y_scale + this.get_top_padding(width);\n        var thick_start = null;\n        var thick_end = null;\n\n        // TODO: is there any reason why block, label color cannot be set at the Painter level?\n        // For now, assume '.' === '+'\n        var block_color =\n            !feature_strand || feature_strand === \"+\" || feature_strand === \".\"\n                ? this.prefs.block_color\n                : this.prefs.reverse_strand_color;\n        var label_color = this.prefs.label_color;\n\n        // Set global alpha.\n        ctx.globalAlpha = this.alpha_scaler.gen_val(feature);\n\n        // In dense mode, put all data in top slot.\n        if (mode === \"Dense\") {\n            slot = 1;\n        }\n\n        if (mode === \"no_detail\") {\n            // No details for feature, so only one way to display.\n            ctx.fillStyle = block_color;\n            ctx.fillRect(f_start, y_start + 5, f_end - f_start, NO_DETAIL_FEATURE_HEIGHT);\n        } else {\n            // Mode is either Squish or Pack:\n            // Feature details.\n            var feature_ts = feature[5];\n\n            var feature_te = feature[6];\n            var feature_blocks = feature[7];\n\n            var // Whether we are drawing full height or squished features\n            full_height = true;\n\n            if (feature_ts && feature_te) {\n                thick_start = Math.floor(Math.max(0, (feature_ts - tile_low) * w_scale));\n                thick_end = Math.ceil(Math.min(width, Math.max(0, (feature_te - tile_low) * w_scale)));\n            }\n\n            // Set vars that depend on mode.\n            var thin_height;\n\n            var thick_height;\n            if (mode === \"Squish\") {\n                thin_height = 1;\n                thick_height = SQUISH_FEATURE_HEIGHT;\n                full_height = false;\n            } else if (mode === \"Dense\") {\n                thin_height = 5;\n                thick_height = DENSE_FEATURE_HEIGHT;\n            } else {\n                // mode === \"Pack\"\n                thin_height = 5;\n                thick_height = PACK_FEATURE_HEIGHT;\n            }\n\n            // Draw feature/feature blocks + connectors.\n            if (!feature_blocks) {\n                // If there are no blocks, treat the feature as one big exon.\n                ctx.fillStyle = block_color;\n                ctx.fillRect(f_start, y_start + 1, f_end - f_start, thick_height);\n                // If strand is specified, draw arrows over feature\n                if (feature_strand && full_height) {\n                    if (feature_strand === \"+\") {\n                        ctx.fillStyle = ctx.canvas.manager.get_pattern(\"right_strand_inv\");\n                    } else if (feature_strand === \"-\") {\n                        ctx.fillStyle = ctx.canvas.manager.get_pattern(\"left_strand_inv\");\n                    }\n                    ctx.fillRect(f_start, y_start + 1, f_end - f_start, thick_height);\n                }\n            } else {\n                //\n                // There are feature blocks and mode is either Squish or Pack.\n                //\n                // Approach: (a) draw whole feature as connector/intron and (b) draw blocks as\n                // needed. This ensures that whole feature, regardless of whether it starts with\n                // a block, is visible.\n                //\n\n                // Compute y axis start position and height\n                var cur_y_start;\n\n                var cur_height;\n                if (mode === \"Squish\" || mode === \"Dense\") {\n                    cur_y_start = y_start + Math.floor(SQUISH_FEATURE_HEIGHT / 2) + 1;\n                    cur_height = 1;\n                } else {\n                    // mode === \"Pack\"\n                    if (feature_strand) {\n                        cur_y_start = y_start;\n                        cur_height = thick_height;\n                    } else {\n                        cur_y_start += SQUISH_FEATURE_HEIGHT / 2 + 1;\n                        cur_height = 1;\n                    }\n                }\n\n                // Draw whole feature as connector/intron.\n                if (this.draw_background_connector) {\n                    if (mode === \"Squish\" || mode === \"Dense\") {\n                        ctx.fillStyle = CONNECTOR_COLOR;\n                    } else {\n                        // mode === \"Pack\"\n                        if (feature_strand) {\n                            if (feature_strand === \"+\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern(\"right_strand\");\n                            } else if (feature_strand === \"-\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern(\"left_strand\");\n                            }\n                        } else {\n                            ctx.fillStyle = CONNECTOR_COLOR;\n                        }\n                    }\n                    ctx.fillRect(f_start, cur_y_start, f_end - f_start, cur_height);\n                }\n\n                // Draw blocks.\n                for (var k = 0, k_len = feature_blocks.length; k < k_len; k++) {\n                    var block = feature_blocks[k];\n\n                    var // -0.5 to offset block between bases.\n                    block_start = Math.floor(Math.max(0, (block[0] - tile_low - 0.5) * w_scale));\n\n                    var block_end = Math.ceil(Math.min(width, Math.max((block[1] - tile_low - 0.5) * w_scale)));\n\n                    var last_block_start;\n                    var last_block_end;\n\n                    // Skip drawing if block not on tile.\n                    if (block_start > block_end) {\n                        continue;\n                    }\n\n                    // Draw thin block.\n                    ctx.fillStyle = block_color;\n                    ctx.fillRect(\n                        block_start,\n                        y_start + (thick_height - thin_height) / 2 + 1,\n                        block_end - block_start,\n                        thin_height\n                    );\n\n                    // If block intersects with thick region, draw block as thick.\n                    // - No thick is sometimes encoded as thick_start == thick_end, so don't draw in that case\n                    if (\n                        thick_start !== undefined &&\n                        feature_te > feature_ts &&\n                        !(block_start > thick_end || block_end < thick_start)\n                    ) {\n                        var block_thick_start = Math.max(block_start, thick_start);\n\n                        var block_thick_end = Math.min(block_end, thick_end);\n                        ctx.fillRect(block_thick_start, y_start + 1, block_thick_end - block_thick_start, thick_height);\n                        if (feature_blocks.length === 1 && mode === \"Pack\") {\n                            // Exactly one block means we have no introns, but do have a distinct \"thick\" region,\n                            // draw arrows over it if in pack mode.\n                            if (feature_strand === \"+\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern(\"right_strand_inv\");\n                            } else if (feature_strand === \"-\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern(\"left_strand_inv\");\n                            }\n                            // If region is wide enough in pixels, pad a bit\n                            if (block_thick_start + 14 < block_thick_end) {\n                                block_thick_start += 2;\n                                block_thick_end -= 2;\n                            }\n                            ctx.fillRect(\n                                block_thick_start,\n                                y_start + 1,\n                                block_thick_end - block_thick_start,\n                                thick_height\n                            );\n                        }\n                    }\n                    // Draw individual connectors if required\n                    if (this.draw_individual_connectors && last_block_start) {\n                        this.draw_connector(ctx, last_block_start, last_block_end, block_start, block_end, y_start);\n                    }\n                    last_block_start = block_start;\n                    last_block_end = block_end;\n                }\n\n                // FIXME: Height scaling only works in Pack mode right now.\n                if (mode === \"Pack\") {\n                    // Reset alpha so height scaling is not impacted by alpha scaling.\n                    ctx.globalAlpha = 1;\n\n                    // Height scaling: draw white lines to reduce height according to height scale factor.\n                    ctx.fillStyle = \"white\"; // TODO: set this to background color.\n                    var hscale_factor = this.height_scaler.gen_val(feature);\n\n                    var // Ceil ensures that min height is >= 1.\n                    new_height = Math.ceil(thick_height * hscale_factor);\n\n                    var ws_height = Math.round((thick_height - new_height) / 2);\n                    if (hscale_factor !== 1) {\n                        ctx.fillRect(f_start, cur_y_start + 1, f_end - f_start, ws_height);\n                        ctx.fillRect(f_start, cur_y_start + thick_height - ws_height + 1, f_end - f_start, ws_height);\n                    }\n                }\n            }\n\n            // Reset alpha so that label is not transparent.\n            ctx.globalAlpha = 1;\n\n            // Draw label for Pack mode.\n            if (feature_name && mode === \"Pack\" && feature_start > tile_low) {\n                ctx.fillStyle = label_color;\n                // FIXME: assumption here that the entire view starts at 0\n                if (tile_low === 0 && f_start - ctx.measureText(feature_name).width < 0) {\n                    ctx.textAlign = \"left\";\n                    ctx.fillText(feature_name, f_end + LABEL_SPACING, y_start + 8, this.max_label_length);\n                    draw_end += ctx.measureText(feature_name).width + LABEL_SPACING;\n                } else {\n                    ctx.textAlign = \"right\";\n                    ctx.fillText(feature_name, f_start - LABEL_SPACING, y_start + 8, this.max_label_length);\n                    draw_start -= ctx.measureText(feature_name).width + LABEL_SPACING;\n                }\n                //ctx.fillStyle = block_color;\n            }\n        }\n\n        // Reset global alpha.\n        ctx.globalAlpha = 1;\n\n        return [draw_start, draw_end];\n    }\n}\n\nclass ReadPainter extends FeaturePainter {\n    constructor(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler, ref_seq, base_color_fn) {\n        super(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler);\n        this.ref_seq = ref_seq ? ref_seq.data : null;\n        this.base_color_fn = base_color_fn;\n    }\n    /**\n     * Returns height based on mode.\n     */\n    get_row_height() {\n        var height;\n        var mode = this.mode;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        } else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        } else {\n            // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n            if (this.prefs.show_insertions) {\n                height *= 2;\n            }\n        }\n        return height;\n    }\n\n    /**\n     * Parse CIGAR string to get (a) a list of contiguous drawing blocks (MD=X) and\n     * (b) an array of [ op_index, op_len ] pairs where op_index is an index into the\n     * string 'MIDNSHP=X' Return value is a dictionary with two entries, blocks and cigar\n     */\n    _parse_cigar(cigar_str) {\n        var cigar_ops = \"MIDNSHP=X\";\n\n        // Parse cigar.\n        var blocks = [[0, 0]];\n\n        var cur_block = blocks[0];\n        var base_pos = 0;\n\n        var // Parse cigar operations out and update/create blocks as needed.\n        parsed_cigar = _.map(cigar_str.match(/[0-9]+[MIDNSHP=X]/g), op => {\n            // Get operation length, character.\n            var op_len = parseInt(op.slice(0, -1), 10),\n                op_char = op.slice(-1);\n\n            // Update drawing block.\n            if (op_char === \"N\") {\n                // At skip, so need to start new block if current block represents\n                // drawing area.\n                if (cur_block[1] !== 0) {\n                    cur_block = [base_pos + op_len, base_pos + op_len];\n                    blocks.push(cur_block);\n                }\n            } else if (\"ISHP\".indexOf(op_char) === -1) {\n                // Operation is M,D,=,X.\n                cur_block[1] += op_len;\n                base_pos += op_len;\n            }\n\n            // Return parsed cigar.\n            return [cigar_ops.indexOf(op_char), op_len];\n        });\n\n        return {\n            blocks: blocks,\n            cigar: parsed_cigar\n        };\n    }\n\n    /**\n     * Draw a single read from reference-based read sequence and cigar.\n     */\n    draw_read(ctx, mode, w_scale, y_start, tile_low, tile_high, feature_start, cigar, strand, read_seq) {\n        // Helper function to update base and sequnence offsets.\n        var update_base_offset = (offset, cig_op, cig_len) => {\n            if (\"M=NXD\".indexOf(cig_op) !== -1) {\n                offset += cig_len;\n            }\n            return offset;\n        };\n\n        var update_seq_offset = (offset, cig_op, cig_len) => {\n            if (\"IX\".indexOf(cig_op) !== -1) {\n                offset += cig_len;\n            }\n            return offset;\n        };\n\n        var // Gets drawing coordinate for a sequence coordinate. Assumes closure variables w_scale and tile_low.\n        get_draw_coord = (\n            sequence_coord // -0.5 to offset sequence between bases.\n        ) => Math.floor(Math.max(0, (sequence_coord - tile_low - 0.5) * w_scale));\n\n        ctx.textAlign = \"center\";\n        var tile_region = [tile_low, tile_high];\n        var base_offset = 0;\n        var seq_offset = 0;\n        var gap = Math.round(w_scale / 2);\n        var char_width_px = ctx.canvas.manager.char_width_px;\n\n        var block_color = strand === \"+\" ? this.prefs.detail_block_color : this.prefs.reverse_strand_color;\n\n        var pack_mode = mode === \"Pack\";\n\n        var draw_height = pack_mode ? PACK_FEATURE_HEIGHT : SQUISH_FEATURE_HEIGHT;\n\n        var rect_y = y_start + 1;\n        var paint_utils = new ReadPainterUtils(ctx, draw_height, w_scale, mode);\n        var drawing_blocks = [];\n        var s_start;\n        var s_end;\n\n        // Keep list of items that need to be drawn on top of initial drawing layer.\n        var draw_last = [];\n\n        // Parse cigar and get drawing blocks.\n        var t = this._parse_cigar(cigar);\n        cigar = t.cigar;\n        drawing_blocks = t.blocks;\n\n        // Draw blocks.\n        for (var i = 0; i < drawing_blocks.length; i++) {\n            var block = drawing_blocks[i];\n\n            if (is_overlap([feature_start + block[0], feature_start + block[1]], tile_region)) {\n                s_start = get_draw_coord(feature_start + block[0]);\n                s_end = get_draw_coord(feature_start + block[1]);\n\n                // Make sure that block is drawn even if it too small to be rendered officially; in this case,\n                // read is drawn at 1px.\n                // TODO: need to ensure that s_start, s_end are calculated the same for both slotting\n                // and drawing.\n                if (s_start === s_end) {\n                    s_end += 1;\n                }\n\n                // Draw read base as rectangle.\n                ctx.fillStyle = block_color;\n                ctx.fillRect(s_start, rect_y, s_end - s_start, draw_height);\n            }\n        }\n\n        // Draw read features.\n        for (var cig_id = 0, len = cigar.length; cig_id < len; cig_id++) {\n            var cig = cigar[cig_id];\n            var cig_op = \"MIDNSHP=X\"[cig[0]];\n            var cig_len = cig[1];\n\n            var seq_start = feature_start + base_offset;\n            s_start = get_draw_coord(seq_start);\n            s_end = get_draw_coord(seq_start + cig_len);\n\n            // Skip feature if it's not in tile.\n            if (!is_overlap([seq_start, seq_start + cig_len], tile_region)) {\n                // Update offsets.\n                base_offset = update_base_offset(base_offset, cig_op, cig_len);\n                seq_offset = update_seq_offset(seq_offset, cig_op, cig_len);\n                continue;\n            }\n\n            // Make sure that read is drawn even if it too small to be rendered officially; in this case,\n            // read is drawn at 1px.\n            // TODO: need to ensure that s_start, s_end are calculated the same for both slotting\n            // and drawing.\n            if (s_start === s_end) {\n                s_end += 1;\n            }\n\n            // Draw read feature.\n            switch (cig_op) {\n                case \"H\": // Hard clipping.\n                case \"S\": // Soft clipping.\n                case \"P\": // Padding.\n                    // Sequence not present and not related to alignment; do nothing.\n                    break;\n                case \"M\": // \"Match\".\n                    // Because it's not known whether there is a match, ignore.\n                    base_offset += cig_len;\n                    break;\n                case \"=\": // Match with reference.\n                case \"X\": // Mismatch with reference.\n                    //\n                    // Draw sequence and/or variants.\n                    //\n\n                    // Get sequence to draw.\n                    var cur_seq = \"\";\n                    if (cig_op === \"X\") {\n                        // Get sequence from read_seq.\n                        cur_seq = read_seq.slice(seq_offset, seq_offset + cig_len);\n                    } else if (this.ref_seq) {\n                        // && cig_op === '='\n                        // Use reference sequence.\n                        cur_seq = this.ref_seq.slice(\n                            // If read starts after tile start, slice at read start.\n                            Math.max(0, seq_start - tile_low),\n                            // If read ends before tile end, slice at read end.\n                            Math.min(seq_start - tile_low + cig_len, tile_high - tile_low)\n                        );\n                    }\n\n                    // Draw sequence. Because cur_seq starts and read/tile start, go to there to start writing.\n                    var start_pos = Math.max(seq_start, tile_low);\n                    for (let c = 0; c < cur_seq.length; c++) {\n                        // Draw base if showing all (i.e. not showing differences) or there is a mismatch.\n                        if ((cur_seq && !this.prefs.show_differences) || cig_op === \"X\") {\n                            // Draw base.\n                            let c_start = Math.floor(Math.max(0, (start_pos + c - tile_low) * w_scale));\n                            ctx.fillStyle = this.base_color_fn(cur_seq[c]);\n                            if (pack_mode && w_scale > char_width_px) {\n                                ctx.fillText(cur_seq[c], c_start, y_start + 9);\n                            } else if (w_scale > 0.05) {\n                                // Require a minimum w_scale so that variants are only drawn when somewhat zoomed in.\n                                ctx.fillRect(c_start - gap, rect_y, Math.max(1, Math.round(w_scale)), draw_height);\n                            }\n                        }\n                    }\n\n                    // Move forward in sequence only if sequence used to get mismatches.\n                    if (cig_op === \"X\") {\n                        seq_offset += cig_len;\n                    }\n                    base_offset += cig_len;\n\n                    break;\n                case \"N\": // Skipped bases.\n                    ctx.fillStyle = CONNECTOR_COLOR;\n                    ctx.fillRect(s_start, rect_y + (draw_height - 1) / 2, s_end - s_start, 1);\n                    // No change in seq_offset because sequence not used when skipping.\n                    base_offset += cig_len;\n                    break;\n                case \"D\": // Deletion.\n                    paint_utils.draw_deletion(s_start, rect_y, cig_len);\n                    base_offset += cig_len;\n                    break;\n                case \"I\": // Insertion.\n                    // Check to see if sequence should be drawn at all by looking at the overlap between\n                    // the sequence region and the tile region.\n                    var insert_x_coord = s_start - gap;\n\n                    if (is_overlap([seq_start, seq_start + cig_len], tile_region)) {\n                        var seq = read_seq.slice(seq_offset, seq_offset + cig_len);\n                        // Insertion point is between the sequence start and the previous base: (-gap) moves\n                        // back from sequence start to insertion point.\n                        if (this.prefs.show_insertions) {\n                            //\n                            // Show inserted sequence above, centered on insertion point.\n                            //\n\n                            // Draw sequence.\n                            // X center is offset + start - <half_sequence_length>\n                            var x_center = s_start - (s_end - s_start) / 2;\n                            if (\n                                (mode === \"Pack\" || this.mode === \"Auto\") &&\n                                read_seq !== undefined &&\n                                w_scale > char_width_px\n                            ) {\n                                // Draw sequence container.\n                                ctx.fillStyle = \"yellow\";\n                                ctx.fillRect(x_center - gap, y_start - 9, s_end - s_start, 9);\n                                draw_last[draw_last.length] = {\n                                    type: \"triangle\",\n                                    data: [insert_x_coord, y_start + 4, 5]\n                                };\n                                ctx.fillStyle = CONNECTOR_COLOR;\n                                // Based on overlap b/t sequence and tile, get sequence to be drawn.\n                                switch (compute_overlap([seq_start, seq_start + cig_len], tile_region)) {\n                                    case OVERLAP_START:\n                                        seq = seq.slice(tile_low - seq_start);\n                                        break;\n                                    case OVERLAP_END:\n                                        seq = seq.slice(0, seq_start - tile_high);\n                                        break;\n                                    case CONTAINED_BY:\n                                        // All of sequence drawn.\n                                        break;\n                                    case CONTAINS:\n                                        seq = seq.slice(tile_low - seq_start, seq_start - tile_high);\n                                        break;\n                                }\n                                // Draw sequence.\n                                for (let c = 0, str_len = seq.length; c < str_len; c++) {\n                                    let c_start = Math.floor(Math.max(0, (seq_start + c - tile_low) * w_scale));\n                                    ctx.fillText(seq[c], c_start - (s_end - s_start) / 2, y_start);\n                                }\n                            } else {\n                                // Draw block.\n                                ctx.fillStyle = \"yellow\";\n                                // TODO: This is a pretty hack-ish way to fill rectangle based on mode.\n                                ctx.fillRect(\n                                    x_center,\n                                    y_start + (this.mode !== \"Dense\" ? 2 : 5),\n                                    s_end - s_start,\n                                    mode !== \"Dense\" ? SQUISH_FEATURE_HEIGHT : DENSE_FEATURE_HEIGHT\n                                );\n                            }\n                        } else {\n                            if (\n                                (mode === \"Pack\" || this.mode === \"Auto\") &&\n                                read_seq !== undefined &&\n                                w_scale > char_width_px\n                            ) {\n                                // Show insertions with a single number at the insertion point.\n                                draw_last.push({\n                                    type: \"text\",\n                                    data: [seq.length, insert_x_coord, y_start + 9]\n                                });\n                            } else {\n                                // TODO: probably can merge this case with code above.\n                            }\n                        }\n                    }\n                    seq_offset += cig_len;\n                    // No change to base offset because insertions are drawn above sequence/read.\n                    break;\n            }\n        }\n\n        //\n        // Draw last items.\n        //\n        ctx.fillStyle = \"yellow\";\n        var item;\n        var type;\n        var data;\n        for (let i = 0; i < draw_last.length; i++) {\n            item = draw_last[i];\n            type = item.type;\n            data = item.data;\n            if (type === \"text\") {\n                ctx.save();\n                ctx.font = `bold ${ctx.font}`;\n                ctx.fillText(data[0], data[1], data[2]);\n                ctx.restore();\n            } else if (type === \"triangle\") {\n                drawDownwardEquilateralTriangle(ctx, data[0], data[1], data[2]);\n            }\n        }\n    }\n\n    /**\n     * Draw a complete read pair\n     */\n    draw_element(ctx, mode, feature, slot, tile_low, tile_high, w_scale, y_scale, width) {\n        // All features need a start, end, and vertical center.\n        // var feature_uid = feature[0];\n        var feature_start = feature[1];\n        var feature_end = feature[2];\n        var feature_name = feature[3];\n\n        var // -0.5 to put element between bases.\n        f_start = Math.floor(Math.max(-0.5 * w_scale, (feature_start - tile_low - 0.5) * w_scale));\n\n        var f_end = Math.ceil(Math.min(width, Math.max(0, (feature_end - tile_low - 0.5) * w_scale)));\n\n        var y_start = (mode === \"Dense\" ? 0 : 0 + slot) * y_scale;\n\n        var draw_height = mode === \"Pack\" ? PACK_FEATURE_HEIGHT : SQUISH_FEATURE_HEIGHT;\n\n        // Draw read.\n        if (feature[5] instanceof Array) {\n            // Read is paired.\n            var connector = true;\n\n            // Draw left/forward read.\n            if (feature[4][1] >= tile_low && feature[4][0] <= tile_high && feature[4][2]) {\n                this.draw_read(\n                    ctx,\n                    mode,\n                    w_scale,\n                    y_start,\n                    tile_low,\n                    tile_high,\n                    feature[4][0],\n                    feature[4][2],\n                    feature[4][3],\n                    feature[4][4]\n                );\n            } else {\n                connector = false;\n            }\n\n            // Draw right/reverse read.\n            if (feature[5][1] >= tile_low && feature[5][0] <= tile_high && feature[5][2]) {\n                this.draw_read(\n                    ctx,\n                    mode,\n                    w_scale,\n                    y_start,\n                    tile_low,\n                    tile_high,\n                    feature[5][0],\n                    feature[5][2],\n                    feature[5][3],\n                    feature[5][4]\n                );\n            } else {\n                connector = false;\n            }\n\n            // Draw connector if both reads were drawn.\n            // TODO: currently, there is no way to connect reads drawn on different tiles; to connect reads on different tiles, data manager\n            // code is needed to join mate pairs from different regions. Alternatively, requesting multiple regions of data at once would\n            // make it possible to put together more easily.\n            // -0.5 to position connector correctly between reads.\n            var b1_end = Math.ceil(\n                Math.min(width, Math.max(-0.5 * w_scale, (feature[4][1] - tile_low - 0.5) * w_scale))\n            );\n\n            var b2_start = Math.floor(Math.max(-0.5 * w_scale, (feature[5][0] - tile_low - 0.5) * w_scale));\n\n            if (connector && b2_start > b1_end) {\n                ctx.fillStyle = CONNECTOR_COLOR;\n                var line_height = y_start + 1 + (draw_height - 1) / 2;\n                dashedLine(ctx, b1_end, line_height, b2_start, line_height);\n            }\n        } else {\n            // Read is single.\n            this.draw_read(\n                ctx,\n                mode,\n                w_scale,\n                y_start,\n                tile_low,\n                tile_high,\n                feature_start,\n                feature[4],\n                feature[5],\n                feature[6]\n            );\n        }\n        if (mode === \"Pack\" && feature_start >= tile_low && feature_name !== \".\") {\n            // Draw label.\n            ctx.fillStyle = this.prefs.label_color;\n            if (tile_low === 0 && f_start - ctx.measureText(feature_name).width < 0) {\n                ctx.textAlign = \"left\";\n                ctx.fillText(feature_name, f_end + LABEL_SPACING, y_start + 9, this.max_label_length);\n            } else {\n                ctx.textAlign = \"right\";\n                ctx.fillText(feature_name, f_start - LABEL_SPACING, y_start + 9, this.max_label_length);\n            }\n        }\n\n        // FIXME: provide actual coordinates for drawn read.\n        return [0, 0];\n    }\n}\n\nclass ArcLinkedFeaturePainter extends LinkedFeaturePainter {\n    constructor(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler) {\n        super(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler);\n        // Need to know the longest feature length for adding spacing\n        this.longest_feature_length = this.calculate_longest_feature_length();\n        this.draw_background_connector = false;\n        this.draw_individual_connectors = true;\n    }\n\n    calculate_longest_feature_length() {\n        var longest_feature_length = 0;\n        for (let i = 0, len = this.data.length; i < len; i++) {\n            var feature = this.data[i];\n            var feature_start = feature[1];\n            var feature_end = feature[2];\n            longest_feature_length = Math.max(longest_feature_length, feature_end - feature_start);\n        }\n        return longest_feature_length;\n    }\n\n    get_top_padding(width) {\n        var view_range = this.view_end - this.view_start;\n        var w_scale = width / view_range;\n        return Math.min(128, Math.ceil(this.longest_feature_length / 2 * w_scale));\n    }\n\n    draw_connector(ctx, block1_start, block1_end, block2_start, block2_end, y_start) {\n        // Arc drawing -- from closest endpoints\n        var x_center = (block1_end + block2_start) / 2;\n        var radius = block2_start - x_center;\n        if (radius > 0) {\n            ctx.beginPath();\n            ctx.arc(x_center, y_start, block2_start - x_center, Math.PI, 0);\n            ctx.stroke();\n        }\n    }\n}\n\n// Color stuff from less.js\n\nclass Color {\n    constructor(rgb, a) {\n        /**\n         * The end goal here, is to parse the arguments\n         * into an integer triplet, such as `128, 255, 0`\n         *\n         * This facilitates operations and conversions.\n         */\n        if (Array.isArray(rgb)) {\n            this.rgb = rgb;\n        } else if (rgb.length == 6) {\n            this.rgb = rgb.match(/.{2}/g).map(c => parseInt(c, 16));\n        } else if (rgb.length == 7) {\n            this.rgb = rgb\n                .substring(1, 7)\n                .match(/.{2}/g)\n                .map(c => parseInt(c, 16));\n        } else {\n            this.rgb = rgb.split(\"\").map(c => parseInt(c + c, 16));\n        }\n        this.alpha = typeof a === \"number\" ? a : 1;\n    }\n\n    eval() {\n        return this;\n    }\n\n    //\n    // If we have some transparency, the only way to represent it\n    // is via `rgba`. Otherwise, we use the hex representation,\n    // which has better compatibility with older browsers.\n    // Values are capped between `0` and `255`, rounded and zero-padded.\n    //\n    toCSS() {\n        if (this.alpha < 1.0) {\n            return `rgba(${this.rgb\n                .map(c => Math.round(c))\n                .concat(this.alpha)\n                .join(\", \")})`;\n        } else {\n            return `#${this.rgb\n                .map(i => {\n                    i = Math.round(i);\n                    i = (i > 255 ? 255 : i < 0 ? 0 : i).toString(16);\n                    return i.length === 1 ? `0${i}` : i;\n                })\n                .join(\"\")}`;\n        }\n    }\n\n    toHSL() {\n        var r = this.rgb[0] / 255;\n        var g = this.rgb[1] / 255;\n        var b = this.rgb[2] / 255;\n        var a = this.alpha;\n        var max = Math.max(r, g, b);\n        var min = Math.min(r, g, b);\n        var h;\n        var s;\n        var l = (max + min) / 2;\n        var d = max - min;\n\n        if (max === min) {\n            h = s = 0;\n        } else {\n            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\n            switch (max) {\n                case r:\n                    h = (g - b) / d + (g < b ? 6 : 0);\n                    break;\n                case g:\n                    h = (b - r) / d + 2;\n                    break;\n                case b:\n                    h = (r - g) / d + 4;\n                    break;\n            }\n            h /= 6;\n        }\n        return { h: h * 360, s: s, l: l, a: a };\n    }\n\n    toARGB() {\n        var argb = [Math.round(this.alpha * 255)].concat(this.rgb);\n        return `#${argb\n            .map(i => {\n                i = Math.round(i);\n                i = (i > 255 ? 255 : i < 0 ? 0 : i).toString(16);\n                return i.length === 1 ? `0${i}` : i;\n            })\n            .join(\"\")}`;\n    }\n\n    mix(color2, weight) {\n        var color1 = this;\n\n        var p = weight; // .value / 100.0;\n        var w = p * 2 - 1;\n        var a = color1.toHSL().a - color2.toHSL().a;\n\n        var w1 = ((w * a == -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n        var w2 = 1 - w1;\n\n        var rgb = [\n            color1.rgb[0] * w1 + color2.rgb[0] * w2,\n            color1.rgb[1] * w1 + color2.rgb[1] * w2,\n            color1.rgb[2] * w1 + color2.rgb[2] * w2\n        ];\n\n        var alpha = color1.alpha * p + color2.alpha * (1 - p);\n\n        return new Color(rgb, alpha);\n    }\n}\n\n// End colors from less.js\n\nclass LinearRamp {\n    constructor(start_color, end_color, start_value, end_value) {\n        /**\n         * Simple linear gradient\n         */\n        this.start_color = new Color(start_color);\n        this.end_color = new Color(end_color);\n        this.start_value = start_value;\n        this.end_value = end_value;\n        this.value_range = end_value - start_value;\n    }\n\n    map_value(value) {\n        value = Math.max(value, this.start_value);\n        value = Math.min(value, this.end_value);\n        value = (value - this.start_value) / this.value_range;\n        // HACK: just red for now\n        // return \"hsl(0,100%,\" + (value * 100) + \"%)\"\n        return this.start_color.mix(this.end_color, 1 - value).toCSS();\n    }\n}\n\nclass SplitRamp {\n    constructor(start_color, middle_color, end_color, start_value, end_value) {\n        /**\n         * Two gradients split away from 0\n         */\n        this.positive_ramp = new LinearRamp(middle_color, end_color, 0, end_value);\n        this.negative_ramp = new LinearRamp(middle_color, start_color, 0, -start_value);\n        this.start_value = start_value;\n        this.end_value = end_value;\n    }\n\n    map_value(value) {\n        value = Math.max(value, this.start_value);\n        value = Math.min(value, this.end_value);\n        if (value >= 0) {\n            return this.positive_ramp.map_value(value);\n        } else {\n            return this.negative_ramp.map_value(-value);\n        }\n    }\n}\n\nclass DiagonalHeatmapPainter extends Painter {\n    constructor(data, view_start, view_end, prefs, mode) {\n        super(data, view_start, view_end, prefs, mode);\n        var i;\n        var len;\n\n        if (this.prefs.min_value === undefined) {\n            var min_value = Infinity;\n            for (i = 0, len = this.data.length; i < len; i++) {\n                min_value = Math.min(min_value, this.data[i][6]);\n            }\n            this.prefs.min_value = min_value;\n        }\n        if (this.prefs.max_value === undefined) {\n            var max_value = -Infinity;\n            for (i = 0, len = this.data.length; i < len; i++) {\n                max_value = Math.max(max_value, this.data[i][6]);\n            }\n            this.prefs.max_value = max_value;\n        }\n    }\n\n    static get default_prefs() {\n        return {\n            min_value: undefined,\n            max_value: undefined,\n            mode: \"Heatmap\",\n            pos_color: \"#FF8C00\",\n            neg_color: \"#4169E1\"\n        };\n    }\n\n    draw(ctx, width, height, w_scale) {\n        var min_value = this.prefs.min_value;\n        var max_value = this.prefs.max_value;\n        var view_start = this.view_start;\n        var invsqrt2 = 1 / Math.sqrt(2);\n\n        var ramp = new SplitRamp(this.prefs.neg_color, \"#FFFFFF\", this.prefs.pos_color, min_value, max_value);\n\n        var d;\n        var s1;\n        var e1;\n        var s2;\n        var e2;\n        var value;\n\n        var scale = p => (p - view_start) * w_scale;\n\n        ctx.save();\n\n        // Draw into triangle, then rotate and scale\n        ctx.rotate(-45 * Math.PI / 180);\n        ctx.scale(invsqrt2, invsqrt2);\n\n        // Paint track.\n        for (var i = 0, len = this.data.length; i < len; i++) {\n            d = this.data[i];\n\n            s1 = scale(d[1]);\n            e1 = scale(d[2]);\n            s2 = scale(d[4]);\n            e2 = scale(d[5]);\n            value = d[6];\n\n            ctx.fillStyle = ramp.map_value(value);\n            ctx.fillRect(s1, s2, e1 - s1, e2 - s2);\n        }\n\n        ctx.restore();\n    }\n}\n\n/**\n * Utilities for painting reads.\n */\nclass ReadPainterUtils {\n    constructor(ctx, row_height, px_per_base, mode) {\n        this.ctx = ctx;\n        this.row_height = row_height;\n        this.px_per_base = px_per_base;\n        this.draw_details = (mode === \"Pack\" || mode === \"Auto\") && px_per_base >= ctx.canvas.manager.char_width_px;\n        this.delete_details_thickness = 0.2;\n    }\n\n    /**\n     * Draw deletion of base(s).\n     * @param draw_detail if true, drawing in detail and deletion is drawn more subtly\n     */\n    draw_deletion(x, y, len) {\n        this.ctx.fillStyle = \"black\";\n        var thickness = (this.draw_details ? this.delete_details_thickness : 1) * this.row_height;\n        y += 0.5 * (this.row_height - thickness);\n        this.ctx.fillRect(x, y, len * this.px_per_base, thickness);\n    }\n}\n\n/**\n * Paints variant data onto canvas.\n */\nclass VariantPainter extends Painter {\n    constructor(data, view_start, view_end, prefs, mode, base_color_fn) {\n        super(data, view_start, view_end, prefs, mode);\n        this.base_color_fn = base_color_fn;\n        this.divider_height = 1;\n    }\n\n    /**\n     * Height of a single row, depends on mode\n     */\n    get_row_height() {\n        var mode = this.mode;\n        var height;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        } else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        } else {\n            // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n        }\n        return height;\n    }\n\n    /**\n     * Returns required height to draw a particular number of samples in a given mode.\n     */\n    get_required_height(num_samples) {\n        // FIXME: for single-sample data, height should be summary_height when zoomed out and\n        // row_height when zoomed in.\n        var height = this.prefs.summary_height;\n\n        // If showing sample data, height is summary + divider + samples.\n        if (num_samples > 1 && this.prefs.show_sample_data) {\n            height += this.divider_height + num_samples * this.get_row_height();\n        }\n        return height;\n    }\n\n    /**\n     * Draw on the context using a rectangle of width x height with scale w_scale.\n     */\n    draw(ctx, width, height, w_scale) {\n        ctx.save();\n\n        var /**\n         * Returns dictionary of information about an indel; returns empty if there no indel. Assumes indel is left-aligned.\n         * Dict attributes:\n         *    -type: 'insertion' or 'deletion'\n         *    -start: where the deletion starts relative to reference start\n         *    -len: how long the deletion is\n         */\n        get_indel_info = (ref, alt) => {\n            var ref_len = ref.length;\n            var alt_len = alt.length;\n            var start = 0;\n            var len = 1;\n            var type = null;\n            if (alt === \"-\") {\n                type = \"deletion\";\n                len = ref.length;\n            } else if (ref.indexOf(alt) === 0 && ref_len > alt_len) {\n                type = \"deletion\";\n                len = ref_len - alt_len;\n                start = alt_len;\n            } else if (alt.indexOf(ref) === 0 && ref_len < alt_len) {\n                // Insertion.\n                type = \"insertion\";\n                len = alt_len - ref_len;\n                start = alt_len;\n            }\n\n            return type !== null ? { type: type, start: start, len: len } : {};\n        };\n\n        // Draw.\n        var locus_data;\n\n        var pos;\n        var ref;\n        var alt;\n        var sample_gts;\n        var allele_counts;\n        var variant;\n        var draw_x_start;\n        var draw_y_start;\n        var genotype;\n\n        var // Always draw variants at least 1 pixel wide.\n        base_px = Math.max(1, Math.floor(w_scale));\n\n        var // Determine number of samples.\n        num_samples = this.data.length ? this.data[0][7].split(\",\").length : 0;\n\n        var row_height = this.mode === \"Squish\" ? SQUISH_TRACK_HEIGHT : PACK_TRACK_HEIGHT;\n\n        var // If zoomed out, fill the whole row with feature to make it easier to read;\n        // when zoomed in, use feature height so that there are gaps in sample rows.\n        feature_height =\n            w_scale < 0.1 ? row_height : this.mode === \"Squish\" ? SQUISH_FEATURE_HEIGHT : PACK_FEATURE_HEIGHT;\n\n        var draw_summary = true;\n\n        var paint_utils = new ReadPainterUtils(ctx, row_height, w_scale, this.mode);\n\n        var j;\n\n        // If there's a single sample, update drawing variables.\n        if (num_samples === 1) {\n            row_height = feature_height =\n                w_scale < ctx.canvas.manager.char_width_px ? this.prefs.summary_height : row_height;\n            paint_utils.row_height = row_height;\n            // No summary when there's a single sample.\n            draw_summary = false;\n        }\n\n        // Draw divider between summary and samples.\n        if (this.prefs.show_sample_data && draw_summary) {\n            ctx.fillStyle = \"#F3F3F3\";\n            ctx.globalAlpha = 1;\n            ctx.fillRect(0, this.prefs.summary_height - this.divider_height, width, this.divider_height);\n        }\n\n        // Draw variants.\n        ctx.textAlign = \"center\";\n        for (var i = 0; i < this.data.length; i++) {\n            // Get locus data.\n            locus_data = this.data[i];\n            pos = locus_data[1];\n            ref = locus_data[3];\n            alt = [locus_data[4].split(\",\")];\n            sample_gts = locus_data[7].split(\",\");\n            allele_counts = locus_data.slice(8);\n\n            // Process alterate values to derive information about each alt.\n            alt = _.map(_.flatten(alt), a => {\n                var alt_info = {\n                    type: \"snp\",\n                    value: a,\n                    start: 0\n                };\n\n                var indel_info = get_indel_info(ref, a);\n\n                return _.extend(alt_info, indel_info);\n            });\n\n            // Only draw locus data if it's in viewing region.\n            if (pos < this.view_start || pos > this.view_end) {\n                continue;\n            }\n\n            // Draw summary for alleles.\n            if (draw_summary) {\n                ctx.fillStyle = \"#999999\";\n                ctx.globalAlpha = 1;\n                for (j = 0; j < alt.length; j++) {\n                    // Draw background for summary.\n                    draw_x_start = this.get_start_draw_pos(pos + alt[j].start, w_scale);\n                    ctx.fillRect(draw_x_start, 0, base_px, this.prefs.summary_height);\n                    draw_y_start = this.prefs.summary_height;\n                    // Draw allele fractions onto summary.\n                    for (j = 0; j < alt.length; j++) {\n                        ctx.fillStyle = alt[j].type === \"deletion\" ? \"black\" : this.base_color_fn(alt[j].value);\n                        var allele_frac = allele_counts / sample_gts.length;\n                        var draw_height = Math.ceil(this.prefs.summary_height * allele_frac);\n                        ctx.fillRect(draw_x_start, draw_y_start - draw_height, base_px, draw_height);\n                        draw_y_start -= draw_height;\n                    }\n                }\n            }\n\n            // Done drawing if not showing samples data.\n            if (!this.prefs.show_sample_data) {\n                continue;\n            }\n\n            // Draw sample genotype(s).\n            draw_y_start = draw_summary ? this.prefs.summary_height + this.divider_height : 0;\n            for (j = 0; j < sample_gts.length; j++, draw_y_start += row_height) {\n                genotype = sample_gts[j] ? sample_gts[j].split(/\\/|\\|/) : [\"0\", \"0\"];\n\n                // Get variant to draw and set drawing properties.\n                variant = null;\n                if (genotype[0] === genotype[1]) {\n                    if (genotype[0] === \".\") {\n                        // TODO: draw uncalled variant.\n                    } else if (genotype[0] !== \"0\") {\n                        // Homozygous for variant.\n                        variant = alt[parseInt(genotype[0], 10) - 1];\n                        ctx.globalAlpha = 1;\n                    }\n                    // else reference\n                } else {\n                    // Heterozygous for variant.\n                    variant = genotype[0] !== \"0\" ? genotype[0] : genotype[1];\n                    variant = alt[parseInt(variant, 10) - 1];\n                    ctx.globalAlpha = 0.5;\n                }\n\n                // If there's a variant, draw it.\n                if (variant) {\n                    draw_x_start = this.get_start_draw_pos(pos + variant.start, w_scale);\n                    if (variant.type === \"snp\") {\n                        var snp = variant.value;\n                        ctx.fillStyle = this.base_color_fn(snp);\n                        if (paint_utils.draw_details) {\n                            ctx.fillText(snp, this.get_draw_pos(pos, w_scale), draw_y_start + row_height);\n                        } else {\n                            ctx.fillRect(draw_x_start, draw_y_start + 1, base_px, feature_height);\n                        }\n                    } else if (variant.type === \"deletion\") {\n                        paint_utils.draw_deletion(draw_x_start, draw_y_start + 1, variant.len);\n                    } else {\n                        // TODO: handle insertions.\n                    }\n                }\n            }\n        }\n\n        ctx.restore();\n    }\n}\n\nexport default {\n    Scaler: Scaler,\n    LinePainter: LinePainter,\n    LinkedFeaturePainter: LinkedFeaturePainter,\n    ReadPainter: ReadPainter,\n    ArcLinkedFeaturePainter: ArcLinkedFeaturePainter,\n    DiagonalHeatmapPainter: DiagonalHeatmapPainter,\n    VariantPainter: VariantPainter\n};\n"]}